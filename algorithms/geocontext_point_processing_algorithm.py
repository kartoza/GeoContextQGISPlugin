# -*- coding: utf-8 -*-

"""
/***************************************************************************
 GeocontextPointProcessing
                                 A QGIS plugin
 This plugin requests all geocontext information for points
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-02-20
        copyright            : (C) 2022 by Kartoza
        email                : divan@kartoza.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Kartoza'
__date__ = '2022-02-20'
__copyright__ = '(C) 2022 by Kartoza'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import sys
import os
import inspect
import time

from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFileDestination,
                       QgsProcessingParameterString,
                       QgsProcessingParameterEnum,
                       QgsVectorLayer,
                       QgsField,
                       QgsSettings)
<<<<<<< HEAD
from requests import exceptions
=======
>>>>>>> 84ad322a14b6c26aacfb037aa5b84ad340cd560a

# Adds the plugin core path to the system path
cur_dir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(cur_dir)
sys.path.insert(0, parentdir)

<<<<<<< HEAD
from bridge_api.api_abstract import ApiClient
from bridge_api.default import (API_DEFAULT_URL,
                                SERVICE,
=======
from bridge_api.default import (SERVICE,
>>>>>>> 84ad322a14b6c26aacfb037aa5b84ad340cd560a
                                GROUP,
                                COLLECTION,
                                TOOL_INPUT_POINT_LAYER,
                                TOOL_REGISTRY,
                                TOOL_KEY,
                                TOOL_FIELD_NAME,
                                TOOL_OUTPUT_POINT_LAYER)

# Adds the plugin core path to the system path
cur_dir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(cur_dir)
sys.path.insert(0, parentdir)

from utilities.utilities import (process_point,
                                 convert_multipart_to_singlepart,
                                 create_vector_file,
                                 get_request_crs,
                                 get_registry_from_index,
                                 service_data_value,
                                 group_data_values,
                                 collection_data_values,
                                 create_new_field,
                                 apply_decimal_places_to_float_tool)


class GeocontextPointProcessingAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

<<<<<<< HEAD
        # Gets the lists of available service, group and collection layers
        self.list_service = self.retrieve_registry_list(API_DEFAULT_URL, SERVICE['key'])  # Service
        self.list_group = self.retrieve_registry_list(API_DEFAULT_URL, GROUP['key'])  # Group
        self.list_collection = self.retrieve_registry_list(API_DEFAULT_URL, COLLECTION['key'])  # Collection
=======
        # Attempts to request the schema configuration from the API
        # try:
        #     client = ApiClient()
        #
        #     response = client.get(schema)  # Retrieve the API schema
        #     self.list_context = response.json()
        #
        # except exceptions.ConnectionError:  # Could not connect to the provided URL
        #     error_msg = "Could not connect to " + schema + ". Check if the provided URL is correct. The site may also be down."
        #     self.iface.messageBar().pushCritical("Connection error: ", error_msg)
        #
        #     self.list_context = []
        # except Exception as e:  # Other possible connection issues
        #     error_msg = "Could not connect to " + schema + ". Unknown error: " + str(e)
        #     self.iface.messageBar().pushCritical("Connection error: ", error_msg)
        #
        #     self.list_context = []

        # Services: ONLY TEMP
        # Services: ONLY TEMP =====================================================================================
        self.list_service = [{'key': 'altitude', 'name': 'Altitude', 'description': 'N/A'},
                             {'key': 'monthly_max_temperature_december', 'name': 'Max temp dec', 'description': 'N/A'},
                             {'key': 'monthly_precipitation_may', 'name': 'Precipitation may', 'description': 'N/A'}]

        # Groups: ONLY TEMP ======================================================================================
        self.list_group = [{'key': 'bioclimatic_variables_group', 'name': 'Bioclimatic layers', 'description': 'N/A'},
                           {'key': 'monthly_precipitation_group', 'name': 'Monthly Precipitation', 'description': 'N/A'},
                           {'key': 'monthly_solar_radiation_group', 'name': 'Monthly Solar Radiation', 'description': 'N/A'},
                           {'key': 'monthly_max_temperature_group', 'name': 'Monthly Maximum Temperature', 'description': 'N/A'}]

        # Collections: ONLY TEMP =================================================================================
        self.list_collection = [{'key': 'global_climate_collection', 'name': 'Global climate collection', 'description': 'N/A'},
                                {'key': 'healthy_rivers_collection', 'name': 'Healthy rivers collection', 'description': 'N/A'},
                                {'key': 'healthy_rivers_spatial_collection', 'name': 'Healthy rivers spatial filters', 'description': 'N/A'},
                                {'key': 'hydrological_regions', 'name': 'Hydrological regions', 'description': 'N/A'},
                                {'key': 'ledet_collection', 'name': 'LEDET collection', 'description': 'N/A'},
                                {'key': 'sa_boundary_collection', 'name': 'South African boundary collection', 'description': 'N/A'},
                                {'key': 'sa_climate_collection', 'name': 'South African climate collection', 'description': 'N/A'},
                                {'key': 'sa_land_cover_land_use_collection', 'name': 'South African land use collection', 'description': 'N/A'},
                                {'key': 'sa_river_ecosystem_collection', 'name': 'South African river collection', 'description': 'N/A'},
                                {'key': 'sedac_collection', 'name': 'Socioeconomic data and application center collection', 'description': 'N/A'}]
>>>>>>> 84ad322a14b6c26aacfb037aa5b84ad340cd560a

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                TOOL_INPUT_POINT_LAYER,
                self.tr(TOOL_INPUT_POINT_LAYER),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        self.addParameter(
            QgsProcessingParameterEnum(
                TOOL_REGISTRY,
                self.tr(TOOL_REGISTRY),
                options=[self.tr(SERVICE['name']), self.tr(GROUP['name']), self.tr(COLLECTION['name'])],
                defaultValue=0,
                optional=False
            )
        )

        # Adds key options to the parameter drop down box ==================================================================================================
        list_keys = []
        for key_to_add in self.list_service:
        #for key_to_add in self.list_group:
        #for key_to_add in self.list_collection:
            list_keys.append(self.tr(key_to_add['name']))

        self.addParameter(
            QgsProcessingParameterEnum(
                TOOL_KEY,
                self.tr(TOOL_KEY),
                options=list_keys,
                defaultValue=0,
                optional=False
            )
        )

        self.addParameter(
            QgsProcessingParameterString(
                TOOL_FIELD_NAME,
                self.tr(TOOL_FIELD_NAME),
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterFileDestination(
                TOOL_OUTPUT_POINT_LAYER,
                self.tr(TOOL_OUTPUT_POINT_LAYER),
                'Geopackage files (*.gpkg)'
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """Processes the point vector layer provided as input.
        """
        input_points = self.parameterAsVectorLayer(parameters, TOOL_INPUT_POINT_LAYER, context)  # QgsVectorLayer
        registry_index = int(self.parameterAsString(parameters, TOOL_REGISTRY, context))  # Integer
        key_index = int(self.parameterAsString(parameters, TOOL_KEY, context))  # Integer
        field_name = self.parameterAsString(parameters, TOOL_FIELD_NAME, context)  # String
        output_points = self.parameterAsFileOutput(parameters, TOOL_OUTPUT_POINT_LAYER, context)  # String

        settings = QgsSettings()
        rounding_factor = settings.value('geocontext-qgis-plugin/dec_places_panel', 3, type=int)

        if input_points.featureCount() <= 0:
            # If the layer contains no features, processing will be stopped
            msg = 'ADD VECTOR LAYER DIRECTORY HERE!'
            self.iface.messageBar().pushCritical("Vector layer contains no features: ", msg)
            return
        else:
            layer_crs = get_request_crs()
            success, input_new, msg = create_vector_file(input_points, output_points, layer_crs)
            if not success:
                # If file creation has been unsuccessful, processing will not continue
                self.iface.messageBar().pushCritical("Vector file creation error: ", msg)
                return

            input_type = input_points.wkbType()  # Vector type for input
            if input_type == 4:  # If a multipoint layer, otherwise skipped
                convert_multipart_to_singlepart(input_new)

            layer_provider = input_new.dataProvider()
            list_points = input_new.getFeatures()  # List of point features contained by the layer
            total = input_new.featureCount()  # Total number of features
            completed = 0  # Used to update the progress bar
            for point in list_points:
                # Stop the algorithm if cancel button has been clicked
                if feedback.isCanceled():
                    feedback.pushInfo("Operation canceled by user.")
                    break

                # Gets the registry and data key
                dict_registry = get_registry_from_index(registry_index)
                dict_key = self.find_name_info(key_index, dict_registry['key'])

                # Request starts
                start = time.time()

                # Retrieves the data from the server
                data_json = process_point(point, dict_registry['key'], dict_key['key'], field_name)

                list_data = []  # This list will store the data. All cases will be services as it will no longer split it into groups/collections
                if dict_registry['key'] == SERVICE['key']:
                    list_data = service_data_value(data_json)
                elif dict_registry['key'] == GROUP['key']:
                    list_data = group_data_values(data_json)
                elif dict_registry['key'] == COLLECTION['key']:
                    list_data = collection_data_values(data_json)
                else:
                    print("UNKNOWN REGISTRY")

                if len(list_data) <= 0:
                    # No data received from the server
                    break
                else:  # List contains data, processing can continue
                    # Creates a list of fields which will be added to the attribute table
                    list_attributes = []
                    for service_data in list_data:
                        field_name = service_data['key']
                        list_attributes.append(QgsField(field_name, QVariant.String))

                    # Adds all of the new fields to the attribute table
                    input_new.startEditing()
                    layer_provider.addAttributes(list_attributes)
                    input_new.updateFields()
                    input_new.updateFeature(point)
                    input_new.commitChanges()

                    # Updates all of the attribute values
                    for service_data in list_data:
                        field_name = service_data['key']
                        data_value = service_data['value']
                        data_value = apply_decimal_places_to_float_tool(data_value, rounding_factor)

                        # Updates the attribute value
                        input_new.startEditing()
                        input_new.changeAttributeValue(point.id(), layer_provider.fieldNameIndex(field_name), data_value)
                        input_new.commitChanges()

                # Request ends
                end = time.time()
                request_time_ms = round((end - start) * 1000, rounding_factor)

                # Update the progress bar
                completed = completed + 1
                feedback.setProgress(int((completed / total) * 100))
                feedback.setProgressText("{} request (ms): {}".format(dict_registry['name'], str(request_time_ms)))

            if not feedback.isCanceled():
                print("CREATE FILE HERE")

            # Return the results of the algorithm
            return {TOOL_OUTPUT_POINT_LAYER: output_points}

<<<<<<< HEAD
    def retrieve_registry_list(self, api_url, registry):
        """Return a list of available layers for the provided registry.

        :param api_url: API URL for doing requests
        :type api_url: str

        :param registry: Registry type: Service, group or collection
        :type registry: str

        :returns: A list of available data in json format
        :rtype: list
        """
        request_url = "{}/registries?registry={}".format(api_url, registry)
        try:
            client = ApiClient()
            response = client.get(request_url)
            list_json = response.json()
        except exceptions.ConnectionError:  # Could not connect to the provided URL
            error_msg = "Could not connect to " + request_url + ". Check if the provided URL is correct. The site may also be down."
            self.iface.messageBar().pushCritical("Connection error: ", error_msg)

            list_json = []
        except Exception as e:  # Other possible connection issues
            error_msg = "Could not connect to " + request_url + ". Unknown error: " + str(e)
            self.iface.messageBar().pushCritical("Connection error: ", error_msg)

            list_json = []

        return list_json

    def find_name_info(self, index, registry):
        """The method finds the key ID of a provided drop down box index.

        :param index: The drop down box index of the key selected by the user
        :type index: Integer

        :param registry: The registry type selected by the user in the panel
        :type registry: String

        :returns: The dictionary of the selected key
        :rtype: Dict
        """
=======
    def find_name_info(self, index, registry):
        """The method finds the key ID of a provided drop down box index.

        :param index: The drop down box index of the key selected by the user
        :type index: Integer

        :param registry: The registry type selected by the user in the panel
        :type registry: String

        :returns: The dictionary of the selected key
        :rtype: Dict
        """
>>>>>>> 84ad322a14b6c26aacfb037aa5b84ad340cd560a
        if registry == SERVICE['key']:
            return self.list_service[index]
        elif registry == GROUP['key']:
            return self.list_group[index]
        elif registry == COLLECTION['key']:
            return self.list_collection[index]

        return None

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Geocontext point processing'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Geocontext'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return GeocontextPointProcessingAlgorithm()

    def helpURL(self):
        return "https://github.com/kartoza/GeoContextQGISPlugin/"

    def shortHelpString(self):
        str = """
        Process a provided point layer by requesting the selected Geocontext data for each of the points in the layer.
        """

    def shortDescription(self):
        return "Process a provided point layer by requesting the selected Geocontext data for each of the points in the layer."

    def icon(self):
        return QIcon("icon.png")

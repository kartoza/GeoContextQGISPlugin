# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'GeoContextQGISPlugin_processing_dialog_base.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


#from _typeshed import NoneType
import os
import sys

from PyQt5.QtWidgets import QDialog
from qgis.PyQt import QtWidgets, uic
from qgis.core import QgsSettings, QgsMapLayer,QgsWkbTypes

# Directory for third party modules
third_party_path = os.path.abspath(os.path.join(os.path.dirname(__file__), 'third_party'))
if third_party_path not in sys.path:
    sys.path.append(third_party_path)

from coreapi.client import Client

# Import the PyQt and QGIS libraries
# this import required to enable PyQt API v2
# do it before Qt imports

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'GeoContextQGISPlugin_processing_dialog_base.ui'))


class ProcessingDialog(QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(ProcessingDialog, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        QDialog.__init__(self, parent)
        self.setupUi(self)

        # Retrieves the schema and request base URLs
        settings = QgsSettings()
        schema = settings.value('geocontext-qgis-plugin/schema', '', type=str)
        url = settings.value('geocontext-qgis-plugin/url', '', type=str)

        # Requests the schema
        client = Client()
        document = client.get(schema)  # Retrieve the API schema

        # Sets the URLs for the processing dialog
        self.lineSchema.setValue(schema)
        self.lineUrl.setValue(url)

        # Retrieves the list of context layers
        self.list_context = client.action(document=document, keys=["csr", "list"])

        # Groups
        self.list_group = [{'key': 'bioclimatic_variables_group', 'name': 'Bioclimatic layers', 'description': 'N/A'},
                           {'key': 'monthly_precipitation_group', 'name': 'Monthly Precipitation', 'description': 'N/A'},
                           {'key': 'monthly_solar_radiation_group', 'name': 'Monthly Solar Radiation', 'description': 'N/A'},
                           {'key': 'monthly_max_temperature_group', 'name': 'Monthly Maximum Temperature', 'description': 'N/A'}]

        # Collections
        self.list_collection = [{'key': 'global_climate_collection', 'name': 'Global climate collection', 'description': 'N/A'},
                                {'key': 'healthy_rivers_collection', 'name': 'Healthy rivers collection', 'description': 'N/A'},
                                {'key': 'healthy_rivers_spatial_collection', 'name': 'Healthy rivers spatial filters', 'description': 'N/A'},
                                {'key': 'hydrological_regions', 'name': 'Hydrological regions', 'description': 'N/A'},
                                {'key': 'ledet_collection', 'name': 'LEDET collection', 'description': 'N/A'},
                                {'key': 'sa_boundary_collection', 'name': 'South African boundary collection', 'description': 'N/A'},
                                {'key': 'sa_climate_collection', 'name': 'South African climate collection', 'description': 'N/A'},
                                {'key': 'sa_land_cover_land_use_collection', 'name': 'South African land use collection', 'description': 'N/A'},
                                {'key': 'sa_river_ecosystem_collection', 'name': 'South African river collection', 'description': 'N/A'},
                                {'key': 'sedac_collection', 'name': 'Socioeconomic data and application center collection', 'description': 'N/A'}]

        # Creates a list of key names and sorts it
        list_key_names = []
        for context in self.list_context:
            name = context['name']
            list_key_names.append(name)
        list_key_names = sorted(list_key_names)

        # Applies the list to the processing dialog
        self.cbKey.addItems(list_key_names)

        key_name = self.cbKey.currentText()
        registry = self.cbRegistry.currentText()

        # Sets the field name to a default value, based on the current selected key name
        self.lineEditFieldName.setText(key_name.replace(' ', '_').replace(",", "") + "_value")

        # Retrieves the set information and updates the description table with it
        dict_current = self.find_name_info(key_name, registry)
        self.tblDetails.setItem(0, 0, QtWidgets.QTableWidgetItem(dict_current['key']))
        self.tblDetails.setItem(0, 1, QtWidgets.QTableWidgetItem(dict_current['name']))
        self.tblDetails.setItem(0, 2, QtWidgets.QTableWidgetItem(dict_current['description']))

        self.cbRegistry.currentTextChanged.connect(self.registry_changed)  # Triggers when the user changes the registry type
        self.cbKey.currentTextChanged.connect(self.key_changed)  # Triggers when the user changes the key name

    def find_name_info(self, search_name, registry):
        """The method finds the key ID of a provided key name. It checks each case until
        the correct case is found.

        :param search_name: The search name to retrieve
        :type search_name: str

        :returns: The key ID of the searched key name; or None if the key could not be found
        :rtype: String
        """

        if registry == "Service":
            for context in self.list_context:
                current_name = context['name']
                if current_name == search_name:
                    return context
        elif registry == "Group":
            for group in self.list_group:
                current_name = group['name']
                if current_name == search_name:
                    return group
        elif registry == "Collection":
            for collection in self.list_collection:
                current_name = collection['name']
                if current_name == search_name:
                    return collection
        return None

    def registry_changed(self):
        """This method is called when the registry option is changed.
        The list in the dialog which contains the key names will be updated.
        """

        registry = self.cbRegistry.currentText()
        self.update_key_list(registry)

    def key_changed(self):
        """This method is called when the key option in the panel window is changed.
        The information in the table which provides a description on the selected
        key will be updated.
        """

        registry = self.cbRegistry.currentText()
        key_name = self.cbKey.currentText()

        # If the key name is empty, this step is skipped
        # This happens when the key list is cleared, which then triggers prior to the updating the list
        if len(key_name) > 0:
            if registry.lower() == 'service':
                self.lblFieldName.setText("Field name")
                self.lineEditFieldName.setText(key_name.replace(' ', '_').replace(",", "") + "_value")
            elif registry.lower() == 'group':
                self.lblFieldName.setText("Field prefix")
                self.lineEditFieldName.setText(key_name.replace(' ', '_').replace(",", "") + "_")
            elif registry.lower() == 'collection':
                self.lblFieldName.setText("Field prefix")
                self.lineEditFieldName.setText(key_name.replace(' ', '_').replace(",", "") + "_")

            dict_current = self.find_name_info(key_name, registry)

            # Updates the table
            self.tblDetails.setItem(0, 0, QtWidgets.QTableWidgetItem(dict_current['key']))
            self.tblDetails.setItem(0, 1, QtWidgets.QTableWidgetItem(dict_current['name']))
            self.tblDetails.setItem(0, 2, QtWidgets.QTableWidgetItem(dict_current['description']))

    def update_key_list(self, registry_type="service"):
        """This method updates the key name list shown in the panel. It will be called when
        the user changes the registry type. Defaults to 'service' if no registry type has
        been provided.
        """

        # Clears the combobox list
        self.cbKey.clear()

        # The registry option has been changed to Service
        if registry_type.lower() == "service":
            settings = QgsSettings()

            # Retrieves the schema URL. This can be set in the options dialog
            schema = settings.value('geocontext-qgis-plugin/schema', '', type=str)

            # Requests the schema from the server
            client = Client()
            document = client.get(schema)  # Retrieve the API schema

            # Requests the list of context layer/data
            self.list_context = client.action(document=document, keys=["csr", "list"])  # Get the list of context layers

            # Lists all of the key names and sorts it alphabetically
            list_key_names = []
            for context in self.list_context:
                name = context['name']
                list_key_names.append(name)
            list_key_names = sorted(list_key_names)

            # Updates the keys in the processing dialog
            self.cbKey.addItems(list_key_names)
        elif registry_type.lower() == "group":
            # Creates a list of the group layers
            list_key_names = []
            for group in self.list_group:
                name = group['name']
                list_key_names.append(name)

            # Updates the keys in the processing dialog
            self.cbKey.addItems(list_key_names)
        elif registry_type.lower() == "collection":
            # Creates a list of the collection layers
            list_key_names = []
            for collection in self.list_collection:
                name = collection['name']
                list_key_names.append(name)

            # Updates the keys in the processing dialog
            self.cbKey.addItems(list_key_names)

    def check_parameters_for_errors(self):
        """Checks each of the parameters provided by the user for errors.

        :returns: True if an error has been found, otherwise False if no error.
        has been found
        :rtype: Boolean
        """

        # Checks whether the input layer provided by the user is valid
        try:
            input_points = self.get_input_layer()
            if input_points.type() == QgsMapLayer.VectorLayer:  # The layer can only be a vector layer
                if not input_points.hasFeatures():  # The layer needs to contain features to be processed
                    return True, "Input layer not provided."
                input_type = input_points.wkbType()  # Vector type
                if not (input_type == 1 or input_type == 4):  # Can only be point or multipoint
                    return True, "Vector type can only be point."
            else:
                return True, "Layer is not of type vector."
        except:
            return True, "Input layer not provided."

        # Checks whether the registry type is valid. An invalid case should not be possible
        registry = self.get_registry()
        if not (registry == "Service" or registry == "Group" or registry == "Collection"):
            return True, "Registry can only be 'Service', 'Group' or 'Collection'."

        key = self.get_key()

        # Checks if the field name or field prefix is valid
        field_name = self.get_fieldname()
        field_name_test = field_name.replace(" ", "").replace("_", "")  # Comma and spaces will be automatically replaced when the field is created
        if len(field_name_test) > 0:  # Field name should contain at least one character
            if not field_name_test.isalnum():  # Field name should be alphanumeric, and therfore contain no other characters
                return True, "Fieldname is not alphanumeric."
        else:
            return True, "Fieldname is empty."

        # Checks if the output directory and file is valid
        output_file = self.get_output_points()
        output_dir = os.path.dirname(output_file)
        output_file_name = os.path.basename(output_file)
        if not os.path.isdir(output_dir):  # Checks if the output directory exists
            return True, "Output directory does not exist."
        if not (output_file_name.endswith(".gpkg") or output_file_name.endswith(".shp")):  # File format can only be shp or gpkg
            return True, "Format can only be geopackage (gpkg) or shapefile (shp)."

        return False, "No error message."

    def get_input_layer(self):
        """Get the input point layer selected by the user, and
        returns it.

        :returns: A vector point layer which contains the all of the points.
        :rtype: QgsVectorLayer
        """
        input_points = self.cbInputPoints.currentLayer()
        return input_points

    def get_selected_option(self):
        """Gets the value set for the selection option in processing dialog.

        :returns: True if selection only is enabled, otherwise False.
        :rtype: Boolean
        """

        selected_features = self.cbSelection.isChecked()

        return selected_features

    def get_registry(self):
        """Returns the registry type, service, group or collection, selected
        by the user.

        :returns: The registry type selected
        :rtype: String
        """

        registry = self.cbRegistry.currentText()

        return registry

    def get_key(self):
        """Returns the key name selected by the user.

        :returns: The key name
        :rtype: String
        """

        key = self.cbKey.currentText()

        return key

    def get_fieldname(self):
        """Returns the field name or prefix provided by the user.

        :returns: The field name/prefix
        :rtype: String
        """

        field_name = self.lineEditFieldName.text()

        return field_name

    def get_output_points(self):
        """Returns the output file directory from the dialog. Is either
        shapefile or geopackage.

        :returns: Output file directory.
        :rtype: String
        """

        output_layer = self.fwOutputPoints.filePath()

        return output_layer

    def get_layer_load_option(self):
        """Return whether the user has selected the option to automatically load
        the newly created point layer.

        :returns: True if the layer should be loaded, otherwise False
        :rtype: Boolean
        """

        load_output_file = self.cbOpenResult.isChecked()

        return load_output_file

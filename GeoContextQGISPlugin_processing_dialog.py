# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'GeoContextQGISPlugin_processing_dialog_base.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import os
import sys

from PyQt5.QtWidgets import QDialog
from qgis.PyQt import QtWidgets, uic
from qgis.core import QgsSettings, QgsMapLayer, QgsWkbTypes, QgsMapLayerProxyModel
from qgis.PyQt.QtCore import QUrl

from .geocontext_help_dialog import HelpDialog

# Directory for third party modules
third_party_path = os.path.abspath(os.path.join(os.path.dirname(__file__), 'third_party'))
if third_party_path not in sys.path:
    sys.path.append(third_party_path)

from coreapi.client import Client
from requests import exceptions

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'GeoContextQGISPlugin_processing_dialog_base.ui'))


class ProcessingDialog(QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(ProcessingDialog, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        QDialog.__init__(self, parent)
        self.setupUi(self)

        self.iface = iface
        self.cbInputPoints.setFilters(QgsMapLayerProxyModel.PointLayer)  # Only point layers can be provided as input

        # Retrieves the schema and request base URLs
        settings = QgsSettings()
        schema = settings.value('geocontext-qgis-plugin/schema', '', type=str)
        url = settings.value('geocontext-qgis-plugin/url', '', type=str)

        # Attempts to request the schema configuration from the API
        try:
            client = Client()
            document = client.get(schema)  # Requests the API schema
            self.list_context = client.action(document=document, keys=["csr", "list"])  # Retrieves the list of context layers
        except exceptions.ConnectionError:  # Could not connect to the provided URL
            error_msg = "Could not connect to " + schema + ". Check if the provided URL is correct. The site may also be down."
            self.iface.messageBar().pushCritical("Connection error: ", error_msg)

            self.list_context = []
        except Exception as e:  # Other possible connection issues
            error_msg = "Could not connect to " + schema + ". Unknown error: " + str(e)
            self.iface.messageBar().pushCritical("Connection error: ", error_msg)

            self.list_context = []

        # Sets the URLs for the processing dialog
        self.lineSchema.setValue(schema)
        self.lineUrl.setValue(url)

        # Groups
        self.list_group = [{'key': 'bioclimatic_variables_group', 'name': 'Bioclimatic layers', 'description': 'N/A'},
                           {'key': 'monthly_precipitation_group', 'name': 'Monthly Precipitation', 'description': 'N/A'},
                           {'key': 'monthly_solar_radiation_group', 'name': 'Monthly Solar Radiation', 'description': 'N/A'},
                           {'key': 'monthly_max_temperature_group', 'name': 'Monthly Maximum Temperature', 'description': 'N/A'}]

        # Collections
        self.list_collection = [{'key': 'global_climate_collection', 'name': 'Global climate collection', 'description': 'N/A'},
                                {'key': 'healthy_rivers_collection', 'name': 'Healthy rivers collection', 'description': 'N/A'},
                                {'key': 'healthy_rivers_spatial_collection', 'name': 'Healthy rivers spatial filters', 'description': 'N/A'},
                                {'key': 'hydrological_regions', 'name': 'Hydrological regions', 'description': 'N/A'},
                                {'key': 'ledet_collection', 'name': 'LEDET collection', 'description': 'N/A'},
                                {'key': 'sa_boundary_collection', 'name': 'South African boundary collection', 'description': 'N/A'},
                                {'key': 'sa_climate_collection', 'name': 'South African climate collection', 'description': 'N/A'},
                                {'key': 'sa_land_cover_land_use_collection', 'name': 'South African land use collection', 'description': 'N/A'},
                                {'key': 'sa_river_ecosystem_collection', 'name': 'South African river collection', 'description': 'N/A'},
                                {'key': 'sedac_collection', 'name': 'Socioeconomic data and application center collection', 'description': 'N/A'}]

        # Checks if the context list contains data
        if len(self.list_context) > 0:
            # Creates a list of key names and sorts it
            list_key_names = []
            for context in self.list_context:
                name = context['name']
                list_key_names.append(name)
            list_key_names = sorted(list_key_names)

            # Applies the list to the processing dialog
            self.cbKey.addItems(list_key_names)

            key_name = self.cbKey.currentText()
            registry = self.cbRegistry.currentText()

            # Sets the field name to a default value, based on the current selected key name
            self.lineEditFieldName.setText(key_name.replace(' ', '_').replace(",", "") + "_value")

            # Retrieves the set information and updates the description table with it
            dict_current = self.find_name_info(key_name, registry)
            self.tblDetails.setItem(0, 0, QtWidgets.QTableWidgetItem(dict_current['key']))
            self.tblDetails.setItem(0, 1, QtWidgets.QTableWidgetItem(dict_current['name']))
            self.tblDetails.setItem(0, 2, QtWidgets.QTableWidgetItem(dict_current['description']))
        else:  # Empty geocontext list. This can be a result of the incorrect URL, or the site is down
            error_msg = "The retrieved context list is empty. Check the provided schema configuration URL or whether the site is online."
            self.iface.messageBar().pushCritical("Empty geocontext list error: ", error_msg)

        # UI triggers
        self.cbRegistry.currentTextChanged.connect(self.registry_changed)  # Triggers when the user changes the registry type
        self.cbKey.currentTextChanged.connect(self.key_changed)  # Triggers when the user changes the key name

        # Buttons clicked
        self.btnHelp.clicked.connect(self.help_btn_click)  # Triggers when the Help button is pressed

    def help_btn_click(self):
        self.show_help()

    def show_help(self):
        """Opens the help dialog. The dialog displays the html documentation.
        The documentation contains information on the processing tool.
        """

        # Directory of the docking_panel.html file used for the help option
        help_file_dir = '%s/resources/help/build/html/processing_tool.html' % os.path.dirname(__file__)
        help_file = 'file:///%s/resources/help/build/html/processing_tool.html' % os.path.dirname(__file__)

        # Checks whether the required html document exist
        if os.path.exists(help_file_dir):
            results_dialog = HelpDialog()
            results_dialog.web_view.load(QUrl(help_file))
            results_dialog.exec_()
        # Skips showing the help file because the plugin cannot find it
        else:
            error_msg = "Cannot find the /resources/help/build/html/processing_tool.html file. Cannot open the help dialog."
            self.iface.messageBar().pushCritical("Missing file: ", error_msg)

    def find_name_info(self, search_name, registry):
        """The method finds the key ID of a provided key name. It checks each case until
        the correct case is found.

        :param search_name: The search name to retrieve
        :type search_name: str

        :param registry: The registry list the method will look into
        :type registry: str

        :returns: The key ID of the searched key name; or None if the key could not be found
        :rtype: String
        """

        if registry == "Service":
            for context in self.list_context:
                current_name = context['name']
                if current_name == search_name:
                    return context
        elif registry == "Group":
            for group in self.list_group:
                current_name = group['name']
                if current_name == search_name:
                    return group
        elif registry == "Collection":
            for collection in self.list_collection:
                current_name = collection['name']
                if current_name == search_name:
                    return collection
        return None

    def registry_changed(self):
        """This method is called when the registry option is changed.
        The list in the dialog which contains the key names will be updated.
        """

        registry = self.cbRegistry.currentText()
        self.update_key_list(registry)

    def key_changed(self):
        """This method is called when the key option in the panel window is changed.
        The information in the table which provides a description on the selected
        key will be updated.
        """

        registry = self.cbRegistry.currentText()
        key_name = self.cbKey.currentText()

        # If the key name is empty, this step is skipped
        # This happens when the key list is cleared, which then triggers prior to the updating the list
        if len(key_name) > 0:
            if registry.lower() == 'service':
                self.lblFieldName.setText("Field name")
                self.lineEditFieldName.setText(key_name.replace(' ', '_').replace(",", "") + "_value")
            elif registry.lower() == 'group':
                self.lblFieldName.setText("Field prefix")
                self.lineEditFieldName.setText(key_name.replace(' ', '_').replace(",", "") + "_")
            elif registry.lower() == 'collection':
                self.lblFieldName.setText("Field prefix")
                self.lineEditFieldName.setText(key_name.replace(' ', '_').replace(",", "") + "_")

            dict_current = self.find_name_info(key_name, registry)

            # Updates the table
            self.tblDetails.setItem(0, 0, QtWidgets.QTableWidgetItem(dict_current['key']))
            self.tblDetails.setItem(0, 1, QtWidgets.QTableWidgetItem(dict_current['name']))
            self.tblDetails.setItem(0, 2, QtWidgets.QTableWidgetItem(dict_current['description']))

    def update_key_list(self, registry_type="service"):
        """This method updates the key name list shown in the panel. It will be called when
        the user changes the registry type. Defaults to 'service' if no registry type has
        been provided.
        """

        # Clears the combobox list
        self.cbKey.clear()

        # The registry option has been changed to Service
        if registry_type.lower() == "service":
            settings = QgsSettings()

            # Retrieves the schema URL. This can be set in the options dialog
            schema = settings.value('geocontext-qgis-plugin/schema', '', type=str)

            # Attempts to retrieve the schema configuration from the API server
            try:
                # Requests the schema from the server
                client = Client()
                document = client.get(schema)  # Retrieve the API schema
                self.list_context = client.action(document=document, keys=["csr", "list"])  # Get the list of context layers
            except exceptions.ConnectionError:  # Could not connect to the provided URL
                error_msg = "Could not connect to " + schema + ". Check if the provided URL is correct. The site may also be down."
                self.iface.messageBar().pushCritical("Connection error: ", error_msg)

                self.list_context = []
            except Exception as e:  # Other possible connection issues
                error_msg = "Could not connect to " + schema + ". Unknown error: " + str(e)
                self.iface.messageBar().pushCritical("Connection error: ", error_msg)

                self.list_context = []

            # Lists all of the key names and sorts it alphabetically
            list_key_names = []
            for context in self.list_context:
                name = context['name']
                list_key_names.append(name)
            list_key_names = sorted(list_key_names)

            # Updates the keys in the processing dialog
            self.cbKey.addItems(list_key_names)
        elif registry_type.lower() == "group":
            # Creates a list of the group layers
            list_key_names = []
            for group in self.list_group:
                name = group['name']
                list_key_names.append(name)

            # Updates the keys in the processing dialog
            self.cbKey.addItems(list_key_names)
        elif registry_type.lower() == "collection":
            # Creates a list of the collection layers
            list_key_names = []
            for collection in self.list_collection:
                name = collection['name']
                list_key_names.append(name)

            # Updates the keys in the processing dialog
            self.cbKey.addItems(list_key_names)

    def check_parameters_for_errors(self):
        """Checks each of the parameters provided by the user for errors.

        :returns: True if an error has been found, otherwise False if no error.
        has been found
        :rtype: Boolean

        :returns: An error message
        :rtype: String
        """

        # Checks whether the input layer provided by the user is valid
        input_points = self.get_input_layer()
        if input_points.type() == QgsMapLayer.VectorLayer:  # The layer can only be a vector layer
            if not input_points.hasFeatures():  # The layer needs to contain features to be processed
                return True, "Input layer not provided."
            input_type = input_points.wkbType()  # Vector type
            if not (input_type == 1 or input_type == 4):  # Can only be point or multipoint
                return True, "Vector type can only be point."
        else:
            return True, "Layer is not of type vector."

        # Checks whether the registry type is valid. An invalid case should not be possible
        registry = self.get_registry()
        if not (registry == "Service" or registry == "Group" or registry == "Collection"):
            return True, "Registry can only be 'Service', 'Group' or 'Collection'."

        # key = self.get_key()

        # Checks if the field name or field prefix is valid
        field_name = self.get_fieldname()
        field_name_test = field_name.replace(" ", "").replace("_", "")  # Comma and spaces will be automatically replaced when the field is created
        if len(field_name_test) > 0:  # Field name should contain at least one character
            if not field_name_test.isalnum():  # Field name should be alphanumeric, and therfore contain no other characters
                return True, "Fieldname is not alphanumeric: " + field_name
        else:
            return True, "Fieldname is empty."

        # Checks if the output directory and file is valid
        output_file = self.get_output_points()
        output_dir = os.path.dirname(output_file)
        output_file_name = os.path.basename(output_file)
        if not os.path.isdir(output_dir):  # Checks if the output directory exists
            return True, "Output directory does not exist: " + output_dir
        # if not (output_file_name.endswith(".gpkg") or output_file_name.endswith(".shp")):  # File format can only be shp or gpkg
        #     return True, "Format can only be geopackage (gpkg) or shapefile (shp)."

        return False, "No error message."

    def get_input_layer(self):
        """Get the input point layer selected by the user, and
        returns it.

        :returns: A vector point layer which contains the all of the points.
        :rtype: QgsVectorLayer
        """
        input_points = self.cbInputPoints.currentLayer()
        return input_points

    def get_selected_option(self):
        """Gets the value set for the selection option in processing dialog.

        :returns: True if selection only is enabled, otherwise False.
        :rtype: Boolean
        """

        selected_features = self.cbSelection.isChecked()

        return selected_features

    def get_registry(self):
        """Returns the registry type, service, group or collection, selected
        by the user.

        :returns: The registry type selected
        :rtype: String
        """

        registry = self.cbRegistry.currentText()

        return registry

    def get_key(self):
        """Returns the key name selected by the user.

        :returns: The key name
        :rtype: String
        """

        key = self.cbKey.currentText()

        return key

    def get_fieldname(self):
        """Returns the field name or prefix provided by the user.

        :returns: The field name/prefix
        :rtype: String
        """

        field_name = self.lineEditFieldName.text()

        return field_name

    def get_output_points(self):
        """Returns the output file directory from the dialog. Is either
        shapefile or geopackage.

        :returns: Output file directory.
        :rtype: String
        """

        output_layer = self.fwOutputPoints.filePath()

        return output_layer

    def get_layer_load_option(self):
        """Return whether the user has selected the option to automatically load
        the newly created point layer.

        :returns: True if the layer should be loaded, otherwise False
        :rtype: Boolean
        """

        load_output_file = self.cbOpenResult.isChecked()

        return load_output_file
